'''Задание: Напишите функцию, которая будет принимать словарь с именем студента
и списком его оценок (типа { "name": "John", "notes": [3, 5, 4] })
и возвращать словарь с именем студента и
самой высокой его оценкой ({ "name": "John", "top_note": 5 }).'''
#
import math

student = { "name": "John", "notes": [1, 3, 5, 4, 2] }
def max_note(stud):
    return { stud['name'] : max(stud['notes'])}
print(max_note(student))
#
#-------------------------------------------------------------------------------
'''Напишите функцию, которая будет инвертировать ключи и значения в словаре. 
Пример: invert({ «z»: «q», «w»: «f» })➞ { «q»: «z», «f»: «w» }'''
dict_norm = {'z':'q', 'w':'f', 'd':'c'}
def invert_dict(d):
    invert_dict = dict()
    for k,v in d.items():
        invert_dict[v] = k
    return invert_dict
print(invert_dict(dict_norm))
'''2 вариант решения'''
def invert_dict2(d):
    return {v:k for k,v in d.items()}
print(invert_dict2(dict_norm))
'''3 вариант решения'''
def invert_dict3(dct):
    return {dct[i]:i for i in dct}
print(invert_dict3(dict_norm))
#------------------------------------------------------------------------
'''Чтобы сократить время, проведенное в дороге, водители часто увеличивают скорость и 
порой даже превышают установленный лимит. На длинных дистанциях это позволяет сэкономить 
некоторое количество времени, а вот на коротких — вряд ли.

Напишите функцию, которая будет высчитывать время, сэкономленное за счет превышения лимита скорости. 
Эта функция будет принимать три числа — лимит скорости, среднюю скорость движения и расстояние, 
которое водитель проехал со средней скоростью.

Примечания:

    Скорость = расстояние / время
    Возвращаемое время должно быть в минутах, а не в часах.
    Скорость передается в км/ч, расстояние — в км.
    Сэкономленное время — разница между временем движения при скоростном лимите и при средней скорости.'''
#-------------------------------------------------------------------------------

def time_saved(limit_speed, average_speed, distance):
    time = (distance/limit_speed)*60 - (distance/average_speed)*60
    return round(time, 1)
print(time_saved(80, 90, 50))
#
#-------------------------------------------------------------------------------------------
'''Напишите функцию, которая будет принимать три числа (a, b, c) и возвращать True, 
если последняя цифра произведения a * b равна последней цифре числа c.'''
def product(a,b,c):
    last_digit_c = str(c)[-1]
    s = a*b
    last_digit_s = str(s)[-1]
    return last_digit_c == last_digit_s
print(product(55, 226, 5190))
'''2 вариант решения'''
def last_dig(a, b, c):
    return str(a * b)[-1] == str(c)[-1]
#-------------------------------------------------------------------------------------------------
'''Как известно, у нас даты обычно записываются в формате dd/mm/yyyy, 
а в США — в формате mm/dd/yyyy. Дата 2 февраля 2020 года — дата-палиндром в обоих форматах (02/02/2020).

Напишите функцию, которая будет принимать дату в формате dd/mm/yyyy и возвращать True, 
если она является датой-палиндромом в обоих форматах. 
В противном случае функция должна возвращать False.

Примеры:
palindromic_date("02/02/2020") ➞ True
palindromic_date("11/12/2019") ➞ False
palindromic_date("11/02/2011") ➞ False
# Хотя 11/02/2011 является датой-палиндромом в формате dd/mm/yyyy,
# она не является таковой в формате mm/dd/yyyy format (02/11/2011)'''
def palindromic_date(date):
    d = date.split('/')
    return d[0] == d[1]
print(palindromic_date("02/02/2020"))
'''2 вариант решения'''
def palindromic_date(date):
    dd,mm,yyyy = date.split('/')
    date1 = ''.join([dd,mm,yyyy])
    date2 = ''.join([mm,dd,yyyy])
    return date1 == date1[::-1] and date2 == date2[::-1]
#--------------------------------------------------------------------------------
'''Напишите функцию, которая будет принимать номер кредитной карты и 
показывать только последние 4 цифры. Остальные цифры должны заменяться звездочками.
card_hide("1234123456785678") ➞ "************5678"
card_hide("8754456321113213") ➞ "************3213"
card_hide("35123413355523") ➞ "**********5523"  '''
#
def card_hide(s):
    last_4 = s[len(s)-4:]
    return f'{"*"*(len(s)-4)}{last_4}'
print(card_hide("123412345678567811"))
'''2 вариант решения'''
def card_hide2(card):
    return '*' * len(card[:-4]) + card[-4:]
#-------------------------------------------------------------------
'''Дана строка, состоящая главным образом из пробелов. 
Среди пробелов есть всего один не-пробельный символ. 
Напишите функцию, принимающую такую строку и проверяющую, 
находится ли этот не-пробельный символ точно по центру строки. 
(Т.е. количество пробелов справа и слева от него должно быть одинаковым).
Примеры:
 is_central(" # ") ➞ True
 is_central(" 2    ") ➞ False
 is_central("@") ➞ True    '''
def is_central(text):
    return text == text[::-1] # строка == перевернутая строка (полиндром)
print(is_central(" 2    "))
'''2 вариант решения'''
def is_central2(text):
    return text.lstrip() == text.rstrip()
print(is_central2("@"))
#
'''Условия:
    функция принимает число (исходим из того, что числа будут целыми и положительными)
    каждая цифра заменяется на число вхождений этой цифры в число
    итоговое число, возвращаемое функцией, должно быть целым числом, а не строкой.

Разбор примера

 digit_count(136116) ➞ 312332
 # Цифра 1 появляется трижды, поэтому все единицы заменяются на тройки.
 # Цифра 3 появляется только один раз, поэтому тройка заменяется единицей.
 # Цифра 6 появляется дважды, поэтому обе шестерки заменяются двойками.
 # Возвращается целое число.

Другие примеры

 digit_count(221333) ➞ 221333
 digit_count(136116) ➞ 312332
 digit_count(2) ➞ 1'''
#
def digit_count(digits):
    count = ''
    digits = str(digits)
    for i in digits:
        count += str(digits.count(i))
    return int(count)
print(digit_count(136116))
'''2 вариант решения'''
def digit_count2(n):
    n = str(n)
    return int(''.join(str(n.count(i)) for i in n))
#--------------------------------------------------------------------------------
'''У вас и вашего соперника есть по 5 самодельных карт. 
Каждая карта помечена какой-нибудь цифрой от 0 до 9 (случайным образом, повторы возможны). 
Выигрывает тот, кто сумел составить наибольшее двузначное число из имеющихся у него цифр.

Напишите функцию, которая будет принимать два списка из 5 цифр каждый 
(первый — ваш, второй — вашего соперника) и возвращать True, 
если в этом раунде побеждаете вы. В случае ничьей или победы соперника возвращается False.
Разбор примера

 win_round([2, 5, 2, 6, 9], [3, 7, 3, 1, 2]) ➞ True
 # Из ваших цифр можно составить число 96
 # Ваш соперник может составить число 73
 # В этом раунде побеждаете вы, потому что 96 > 73'''
#
def win_round(list1, list2):
    max1 = int(''.join([''.join(str(i)) for i in sorted(list1)[:2:-1]]))# получаем в отсортированном
    # списке по возрост. два последн элемента.
    #  реверсируем его, что-бы получилось мах.число.
    max2 = int(''.join([''.join(str(i)) for i in sorted(list2)[:2:-1]]))
    return max1
print(win_round([2, 5, 2, 6, 9], [3, 7, 3, 1, 2]))
print(win_round([1, 2, 3, 4, 5], [9, 8, 7, 6, 5]))
'''2 вариант решения   интерестнее'''
def win_round(you, opp):
    #  sorted(you)[:2:-1]  получаем в отсортированном списке по возрост. два последн элемента.
    #  реверсируем его, что-бы получилось мах.число.
    return sorted(you)[:2:-1] > sorted(opp)[:2:-1]

l = [9, 8, 7, 6, 5,4,7,1]
# sorted(l) -> [5, 6, 7, 8, 9]
print(sorted(l)[::-1][:2]) # Eще один вариант: реверсируем срезом отсортиров.
                            # список и берем первые два элемента.
'''3 вариант решения через lambda Интерестное.'''
def win_round(you, opp):
    highest = lambda x: int(''.join(map(str, sorted(x, reverse=True)[:2])))
    return highest(you) > highest(opp)
#-------------------------------------------------------------
'''Напишите функцию, которая будет принимать число и возвращать его в виде 
денежной суммы в долларах (и центах) США.
Примечания

    Нужно обязательно округлять дробную часть числа до сотых.
    Обратите внимание, что дробная часть числа в денежном формате отделяется точкой, 
    а тысячи разделяются запятыми.
    В функцию могут передаваться как положительные, так и отрицательные числа.

Примеры

 dolla_dolla_bills(10) ➞ "$10.00"
 dolla_dolla_bills(1000000) ➞ "$1,000,000.00"
 dolla_dolla_bills(-314159.2653) ➞ "-$314,159.27"
 dolla_dolla_bills(-56.99) ➞ "-$56.99"'''

def dolla_dolla_bills(x):
    return '${:,.2f}'.format(x) #Номера форматирования с использованием
                                # запятой в качестве тысяч сепаратор .2f - 2 знака после запятой
print(dolla_dolla_bills(1000))
#---------------------------------------------------------------------------------
'''Напишите функцию, которая будет принимать строку и возвращать отсортированный список 
трехбуквенных групп. Список формируется следующим образом: берем первые три буквы строки, 
затем сдвигаемся на одну букву и берем следующие три буквы и т. д. 
Если в переданной строке меньше трех букв, нужно вернуть пустой список.
Разбор примера

 three_letter_collection("python") ➞ ["hon", "pyt", "tho", "yth"]
 # 1-я группа: "hon"
 # 2-я группа: "pyt"
 # 3-я группа: "tho"
 # 4-я группа: "yth"
 # Не забудьте отсортировать список! 

Примеры

 three_letter_collection("slap") ➞ ["lap", "sla"]
 three_letter_collection("click") ➞ ["cli", "ick", "lic"]
 three_letter_collection("cat") ➞ ["cat"]
 three_letter_collection("hi") ➞ []'''
#
def three_letter_collection(l):
    list_str = []
    k = 3 # эту переменную можно и не обявлять
    for i in range(len(l)-2):
        list_str.append(l[i:k]) # вместо k - (i+3)
        k+=1 #
    return sorted(list_str)
print(three_letter_collection("hi"))
'''2 вариант решения через ф-цию-генератор'''
def three_letter_collection(s):
    return sorted(s[i:i+3] for i in range(len(s)-2))
#--------------------------------------------------------------
'''Представьте, что вы на экзамене. Время вышло, преподаватель говорит дописать 
предложение до точки и сдать работу.

Допустим, написание одной буквы занимает 0,5 с (пробелы не учитываем).

Напишите функцию, которая будет принимать полное и недописанное предложение, 
а возвращать время, необходимое на дописывание (в секундах).
Разбор примера

 time_to_finish(
   "And so brings my conclusion to its conclusion.",
   "And so brings my conclusion to"
 ) ➞ 7
  
 # "its" - это 3 символа
 # "conclusion." - 11 символов, включая точку.
 # 11 + 3 = 14
 # 14 x 0.5 = 7
 # Помните, что пробелы не учитываются. 

Примеры
1.
time_to_finish(
   "And so brings my conclusion to its conclusion.",
   "And so brings my conclusion to its conclus"
 ) ➞ 2

 2.
 time_to_finish(
   "As a result, my point is still valid.",
   "As a result, my"
 ) ➞ 9'''
#
def time_to_finish(str1,str2):
    l1 =  ''.join(str1.split()) # убираем пробелы в строке
    l2 =  ''.join(str2.split()) # убираем пробелы в строке
    return (len(l1) - len(l2)) * 0.5
print(time_to_finish("And so brings my conclusion to its conclusion.",
   "And so brings my conclusion to its conclus"))
'''2 вариант решения'''
def time_to_finish1(full, part):
    return len(full.replace(part, "").replace(" ", "")) * 0.5
'''3 вариант решения - интерестнее'''
def time_to_finish2(full, part):
    return len(full[len(part):].replace(' ', '')) / 2
#------------------------------------------------------------------------------
'''Напишите функцию, которая будет принимать строку из уникальных букв 
и возвращать отсортированную строку из букв, которых не было в переданной строке.
Примечания

    Подразумевается использование английского алфавита. 
    Всего в двух строках должно быть 26 букв.
    Все буквы будут в нижнем регистре.

Примеры:

 get_missing_letters("abcdefgpqrstuvwxyz") ➞ "hijklmno"
 get_missing_letters("zyxwvutsrq") ➞ "abcdefghijklmnop"
 get_missing_letters("abc") ➞ "defghijklmnopqrstuvwxyz"
 get_missing_letters("abcdefghijklmnopqrstuvwxyz") ➞ ""'''
#
def get_missing_letters(str1):
    set1 = set("abcdefghijklmnopqrstuvwxyz")
    set2 = set(str1)
    return ''.join(sorted(set1 - set2))
print(get_missing_letters("zyxwvutsrq"))
'''2 вариант решения'''
def get_missing_letters1(s):
    return ''.join(sorted(set('abcdefghijklmnopqrstuvwxyz') - set(s)))
'''3 вариант решения - Интерестное без использования множеств.'''
def get_missing_letters2(s):
    output = 'abcdefghijklmnopqrstuvwxyz'
    for letter in s:
        output = output.replace(letter, '')
    return output
#------------------------------------------------------------------------------
'''Напишите функцию, которая будет принимать список цифр и проверять, 
встречается ли заданная цифра указанное число раз подряд. 
Функция должна возвращать True или False. Исходим из того, 
что все параметры всегда будут валидными.

Шаблон:

 is_there_consecutive([lst], n, times)

    [lst] — список может быть любой длины, цифры идут в произвольном порядке
    n — цифра, которую нужно проверять
    times — сколько раз подряд должна встретиться цифра n

Примеры

 is_there_consecutive([1, 3, 5, 5, 3, 3, 1], 3, 2) ➞ True
 is_there_consecutive([1, 2, 3, 4, 5], 1, 1) ➞ True
 is_there_consecutive([3], 1, 0) ➞ True
 is_there_consecutive([2, 2, 3, 2, 2, 2, 2, 3, 4, 1, 5], 3, 2) ➞ False
 is_there_consecutive([5, 5, 5, 5, 5], 5, 7) ➞ False'''
#  !!! Интерестная задача
def is_there_consecutive(lst, n, count):
    return lst.count(n) >= count
print(is_there_consecutive([1, 3, 5, 5, 3, 3, 1], 3, 2))
print(is_there_consecutive([1, 2, 3, 4, 5], 1, 1))
print(is_there_consecutive([3], 1, 0))
print(is_there_consecutive([5, 5, 5, 5, 5], 5, 7))
print(is_there_consecutive([2, 2, 3, 2, 2, 2, 2, 3, 4, 1, 5], 3, 2))
#
def is_there_consecutive2(lst, n, count):
    str_lst = map(str, lst) # Переводим список из чисел в строку
    #str_lst = ''.join(str(i) for i in lst) # Переводим список из чисел в строку (2 вариант)
    str_count = str(n) * count             # Переводим число в строку и умнож. на count ->
                                           # получаем строку из идущ.подряд чисел
    return str_count in str_lst            # Сравниваем вхождение
print(is_there_consecutive2([2, 2, 3, 2, 2, 2, 2, 3, 4, 1, 5], 3, 2))
print(is_there_consecutive2([1, 2, 3, 4, 5], 1, 1))
#----------------------------------------------------------------------------
print('-'*10)
for i in range(1, 9):
    for j in range(1, i+1):
        print(f'#j = {j}')
    print('-'*10)
